\begin{tutorial}{Longest Common Subsequence}

This problem tries to find a common subsequence in the form $1^x2^y3^z$ and the value 
 $x+y+z$ is maximum.

Let's try to fix $x$ and $z$, we need to find the $x$ first $1$ and the $z$ last $3$ in $a$ or $b$. After that, let the remaining subsegment in $a$ and $b$ be $[l_a,r_a]$ and $[l_b,r_b]$. The value of $y$ will just be the minimum occurrence of $2$ in each of the subsegment.

Let $sa(i)$ be the number $2$ in $a_1,a_2,\dots,a_i$ and $sb(i)$ be the number of $2$ in $b_1,b_2,\dots,b_i$. We can formula the above description as:
$$
\min(sa(r_a)-sa(l_a-1), sb(r_b)-sb(l_b-1)).
$$

Consider $sa(r_a)-sa(l_a-1) \ge sb(r_b)-sb(l_b-1)$ first, i.e. $sa(r_a)-sb(r_b) \ge sb(l_b-1) - sa(l_a-1)$. The optimal value is $sb(r_b)-sb(l_b-1)+z$. We can use a data structure to maintain the $key=sa(r_a)-sb(r_b)$ and $value=z-sb(l_b-1)$. And if we enumerate $x$ from $n$ to $1$, and add the corresponding item with $key=sa(r_a)-sb(r_b)$ into the data structure, we can query the suffix minimum value of $key \ge sb(l_b-1) - sa(l_a-1)$ to get the optimal value.

And for $sa(r_a)-sa(l_a-1) \le sb(r_b)-sb(l_b-1)$, the case is similar. Since we only need to query suffix minimum value, we can use binary index tree.

The time complexity is $O(n \log n)$. 

And there also exists an $O(n)$ solution which is left as a challenge for participants.

\end{tutorial}
